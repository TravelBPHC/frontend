/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

const VERSION = require("../package.json").version;

// Uncomment 21 to 72 for Push Notifs

/* eslint-disable-next-line no-restricted-globals */
// self.addEventListener("push", async function async(event) {
//   console.log("Push Notification received", event);
//   const data = await event?.data.json();
//   try {
//     console.log("Push Notification DATA: ", data);
//     let message = "";
//     let title = "";
//     if (data?.type === "request accepted") {
//       title = "Request Accepted!";
//       message =
//         "Your request for the trip to " +
//         data?.destination +
//         "on " +
//         // change date to departure_date everywhere
//         data?.departure_date +
//         " has been accepted by " +
//         data?.sender +
//         "!";
//     } else if (data?.type === "request rejected") {
//       title = "Request Rejected";
//       message =
//         "Your request for the trip to " +
//         data?.destination +
//         "on " +
//         data?.departure_date +
//         " has been rejected by " +
//         data?.sender;
//     } else if (data?.type === "new request") {
//       console.log("new request");
//       title = "New Request";
//       message =
//         data?.sender +
//         " wants to travel with you on " +
//         data?.departure_date +
//         " to " +
//         data?.destination;
//     } else {
//       title = "Error";
//       message = "Something went wrong";
//     }

//     /* eslint-disable-next-line no-restricted-globals */
//     self.registration.showNotification(title, { body: message });
//   } catch (error) {
//     console.log("Push Notification received: ", event);
//     console.log("Push Notification ERROR: ", error);
//   }

//   const promiseChain = Promise.all([data]);

//   event.waitUntil(promiseChain);
// });

// self.addEventListener("activate", function (event) {
//   event.waitUntil(
//     caches.keys().then(function (cacheNames) {
//       return Promise.all(
//         cacheNames
//           .filter(function (cacheName) {
//             if (cache.includes(cacheName)) {
//               return true;
//             }
//             return false;
//           })
//           .map(function (cacheName) {
//             return caches.delete(cacheName);
//             // console.log(cacheName);
//           })
//       );
//     })
//   );
// });

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith("/_")) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: "images",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

self.addEventListener("statechange", (event) => {
  if (event.target.state === "activated") {
    console.log("NEW UPDATE INCOMING");
    if (
      window.confirm(
        "There is a new version of the app ready. Please reload to update."
      )
    ) {
      window.location.reload();
    }
  }
});

// Any other custom service worker logic can go here.
